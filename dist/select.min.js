const _slice=(e,t,r)=>e.slice(t,r),init=e=>_slice(e,0,-1),isArray=Array.isArray,append=(e,t)=>e.concat(t),isString=e=>"string"==typeof e,isNumber=e=>e==e&&"number"==typeof e,isFunction=e=>"function"==typeof e,isObject=e=>"[object Object]"===Object.prototype.toString.call(e),keys=Object.keys,len=e=>e.length,nul=e=>0===len(e),trim=e=>e.trim(),take=(e,t)=>_slice(t,0,e<0?0:e),drop=(e,t)=>_slice(t,e<0?0:e),copy=e=>_slice(e),last=e=>e[len(e)-1],extend=(e,t)=>Object.assign({},e,t),toLower=e=>isString(e)?e.toLowerCase():e,floor=Math.floor,ceil=Math.ceil,minFn=(e,t)=>t<e?t:e,maxFn=(e,t)=>t>e?t:e,isElem=(e,t)=>t.indexOf(e)>-1,_set=(e,t,r)=>{const n=new Set,s=new Set(t);for(let t of e)s.has(t)===r&&n.add(t);return[...n]},intersect=(e,t)=>_set(e,t,!0),difference=(e,t)=>_set(e,t,!1),isUniq=e=>new Set(e).size===len(e),isSubset=(e,t)=>{const r=new Set(t),n=r.size;for(let t of e)r.add(t);return n===r.size},any=e=>t=>t.some(e),all=e=>t=>t.every(e),map=e=>t=>t.map(e),each=e=>t=>t.forEach(e),filter=e=>t=>t.filter(t=>e(t)),mapKeys=(e,t)=>{const r=Object.create(null);for(let n of t)r[n]=e(n);return r},concat=(...e)=>{const t=[];for(let r of e)for(let e of r)t.push(e);return t},pick=e=>t=>{const r={};for(let n of e)r[n]=t[n];return r},select=e=>t=>map(pick(e))(t),_pick=e=>t=>{const r={};for(let n of e)r[n]=null==t[n]?null:t[n];return r},_select=e=>t=>map(_pick(e))(t),pickTS=e=>t=>{const r={};for(let n of e)r[n[0]]=null==t[n[1]]?null:t[n[1]];return r},pick2=(e,t,r)=>(n,s)=>{const o={};for(let t of e)o[t]=null==n[t]?null:n[t];for(let e of t)o[e]=null==s[e]?null:s[e];return r&&r(o,n,s),o},pick2KTS=(e,t,r)=>(n,s)=>{const o={};for(let t of e)o[t]=null==n[t]?null:n[t];for(let e of t)o[e[0]]=null==s[e[1]]?null:s[e[1]];return r&&r(o,n,s),o},pick2TSK=(e,t,r)=>(n,s)=>{const o={};for(let t of e)o[t[0]]=null==n[t[1]]?null:n[t[1]];for(let e of t)o[e]=null==s[e]?null:s[e];return r&&r(o,n,s),o},pick2TS=(e,t,r)=>(n,s)=>{const o={};for(let t of e)o[t[0]]=null==n[t[1]]?null:n[t[1]];for(let e of t)o[e[0]]=null==s[e[1]]?null:s[e[1]];return r&&r(o,n,s),o},equalBy=e=>(t,r)=>e(t)===e(r),_nubSorted=(e,t)=>{const r=len(e);if(!r)return[];const n=[];let s=0,o=n[len(n)]=e[s++];for(;s<r;)o=t(o,e[s])?o:n[len(n)]=e[s],s++;return n},nubSBy=(e,t)=>_nubSorted(t,e),cmp_nul=(e,t,r)=>e===t?0:null==e?-1:null==t?1:r(e,t),cmp2=(e,t)=>e<t?-1:1,cmp3=(e,t)=>e.localeCompare(t),ascn=e=>(t,r)=>cmp_nul(e(t),e(r),cmp2),descn=e=>(t,r)=>-cmp_nul(e(t),e(r),cmp2),ascn_loc=e=>(t,r)=>(t=e(t),cmp_nul(t,e(r),isString(t)?cmp3:cmp2)),descn_loc=e=>(t,r)=>(t=e(t),-cmp_nul(t,e(r),isString(t)?cmp3:cmp2));class Node{constructor(e,t){this.color=e,this.value=t,this.left=null,this.right=null}}const RED=!0,BLACK=!1;class Tree{constructor(){this.root=null,this.compare=((e,t)=>e<t?-1:e>t?1:0),this.map={}}isRed(e){return null!=e&&e.color===RED}isBlack(e){return null!=e&&e.color===BLACK}rotateLeft(e){const t=e.right;return e.right=t.left,t.left=e,t.color=e.color,e.color=RED,t}rotateRight(e){const t=e.left;return e.left=t.right,t.right=e,t.color=e.color,e.color=RED,t}colorFlip(e){e.color=!e.color,e.left.color=!e.left.color,e.right.color=!e.right.color}max(e){for(;null!=e.right;)e=e.right;return e}min(e){for(;null!=e.left;)e=e.left;return e}get maxValue(){return null!=this.root?this.max(this.root).value:null}get minValue(){return null!=this.root?this.min(this.root).value:null}moveRedLeft(e){return this.colorFlip(e),this.isRed(e.right.left)&&(e.right=this.rotateRight(e.right),e=this.rotateLeft(e),this.colorFlip(e)),e}moveRedRight(e){return this.colorFlip(e),this.isRed(e.left.left)&&(e=this.rotateRight(e),this.colorFlip(e)),e}fixUp(e){return this.isRed(e.right)&&(e=this.rotateLeft(e)),this.isRed(e.left)&&this.isRed(e.left.left)&&(e=this.rotateRight(e)),this.isRed(e.left)&&this.isRed(e.right)&&this.colorFlip(e),e}deleteMin(e){return null==e.left?null:(this.isBlack(e.left)&&!this.isRed(e.left.left)&&(e=this.moveRedLeft(e)),e.left=this.deleteMin(e.left),this.fixUp(e))}_insert(e,t){if(null==e)return new Node(RED,t);const r=this.compare(t,e.value);return r<0?e.left=this._insert(e.left,t):r>0?e.right=this._insert(e.right,t):e.value=t,this.fixUp(e)}_delete(e,t){if(null==e)return null;let r=this.compare(t,e.value);if(r<0)this.isBlack(e.left)&&!this.isRed(e.left.left)&&(e=this.moveRedLeft(e)),e.left=this._delete(e.left,t);else{if(this.isRed(e.left)&&(e=this.rotateRight(e)),0===r&&null==e.right)return null;this.isBlack(e.right)&&!this.isRed(e.right.left)&&(e=this.moveRedRight(e)),0===(r=this.compare(t,e.value))?(e.value=this.min(e.right).value,e.right=this.deleteMin(e.right)):e.right=this._delete(e.right,t)}return this.fixUp(e)}insert(e){this.map[e]=(this.map[e]||0)+1,1===this.map[e]&&(this.root=this._insert(this.root,e),this.root.color=BLACK)}remove(e){1===this.map[e]?(this.map[e]=0,this.root=this._delete(this.root,e),null!=this.root&&(this.root.color=BLACK)):this.map[e]--}}class SqlSelectError extends Error{}const _throw=e=>{throw new SqlSelectError(e)},_prodSQL=({fn:e,t1:t,t2:r})=>{const n=len(t),s=len(r),o=Array(n*s);let l,i=0,c=-1;for(;++c<n;)for(l=-1;++l<s;)o[i++]=e(t[c],r[l]);return o},buildHash=(e,t,r)=>{let n,s;for(let o of e)null!=(n=o[t])&&(r.has(n)?(s=r.get(n),isArray(s)?s.push(o):r.set(n,[s,o])):r.set(n,o))},_hashjoin=(e,t,r,n,s,o,l,i,c)=>{const a=new Map;buildHash(r,s,a);const u=[];let p,f,h,_,g;o&&(h=mapKeys(e=>null,c)),l&&(f=mapKeys(e=>null,i),g=new Set);for(let r of t)if(_=r[n],a.has(_))if(l&&g.add(_),p=a.get(_),isArray(p))for(let t of p)u.push(e(r,t));else u.push(e(r,p));else o&&u.push(e(r,h));if(l)for(let t of r)_=t[s],g.has(_)||u.push(e(f,t));return u},buildSet=(e,t,r)=>{let n;for(let s of e)null!=(n=s[t])&&r.add(n)},_semijoin=(e,t,r,n,s,o)=>{const l=new Set;buildSet(r,s,l);const i=[];let c,a;for(let r of t)a=r[n],c=l.has(a),o?c&&i.push(e(r)):c||i.push(e(r));return i},cmp=e=>(t,r)=>{const n=len(e);let s=0,o=0;for(;0===s&&o<n;)s=e[o++](t,r);return s},_eqs=e=>(t,r)=>{const n=len(e);let s=!0,o=0;for(;s&&o<n;)s=e[o++](t,r);return s},_flip=e=>(t,r)=>e(r,t),flip=({fn:e,t1:t,t2:r,str1:n,str2:s,tgs1:o,tgs2:l},i,c)=>len(t)>=len(r)?_hashjoin(e,t,r,n,s,i,c,o,l):_hashjoin(_flip(e),r,t,s,n,c,i,l,o),hashjoin=e=>flip(e,!1,!1),leftjoin=e=>flip(e,!0,!1),rightjoin=e=>flip(e,!1,!0),fulljoin=e=>flip(e,!0,!0),leftsemijoin=({fn:e,t1:t,t2:r,str1:n,str2:s})=>_semijoin(e,t,r,n,s,!0),rightsemijoin=({fn:e,t1:t,t2:r,str1:n,str2:s})=>_semijoin(e,r,t,s,n,!0),leftantijoin=({fn:e,t1:t,t2:r,str1:n,str2:s})=>_semijoin(e,t,r,n,s),rightantijoin=({fn:e,t1:t,t2:r,str1:n,str2:s})=>_semijoin(e,r,t,s,n),avgFn=(e,t)=>{for(let r=0;r<e.length;r++)e[r][t]=e[r][t]&&e[r][t].count?e[r][t].sum/e[r][t].count:null},sumFn=(e,t,r)=>{for(let n=0;n<e.length;n++)e[n][t]=e[n][t]&&e[n][t].count?e[n][t].sum:r},executeUnordered=(e,t,r,n)=>{const s=len(e);let o,l,i,c=0,a=-1;for(t.fromWin=!0;++a<s;){for(o=e[a],l=t.fn(null,r,c,o),i=-1;++i<o;)r[c+i][n]=l;c+=o}t.avg&&avgFn(r,n),t.sum&&sumFn(r,n,null)},exNulls=(e,t,r)=>{const n=e.count?0:null,s=len(t);let o=-1;for(;++o<s;)t[o][r]=n},executeRows=(e,t,r,n,s,o,l,i)=>{const c=len(e),a=l<=0,u=i<=0,p=t.min,f=t.max,h=t.count?0:null;let _,g,d,m,S,E,b,x,N,A,k,R,O,w=-1,F=0,T=-1;for(t.fromWin=!0;++T<c;){for(g=(d=F+(_=e[T]))-1,x=!1,k=!0,S=0;S<_;){if(E=F+S,s&&E+l<F)b=E+i,u?(m=b<F?h:t.fn(null,r,b,1),r[E][n]=b>F?t.fnP(r[E-1][n],m):m):b<d?(m=E===F?t.fn(null,r,F,1+i):t.fn(null,r,b,1),r[E][n]=E>F?t.fnP(r[E-1][n],m):m):r[E][n]=E>F?r[E-1][n]:t.fn(null,r,E,_);else{if(o&&E+i>g){x=!0;break}k?(k=!1,p||f?(N=new Tree,t.fn(null,r,E+l,1+i-l,N),r[E][n]=p?N.minValue:N.maxValue):r[E][n]=E===F?t.fn(null,r,E+l,1+i-l):t.fnP(r[E-1][n],t.fn(null,r,E+i,1))):p||f?(null!=(R=t.fn(null,r,E+l-1,1))&&N.remove(R),null!=(O=t.fn(null,r,E+i,1))&&N.insert(O),r[E][n]=p?N.minValue:N.maxValue):(A=t.fnM(r[E-1][n],t.fn(null,r,E+l-1,1)),r[E][n]=t.fnP(A,t.fn(null,r,E+i,1)))}S++}if(x)for(w=F-1,S=0;S<_&&(E=g-S)+i>g;)b=E+l,a?b>w?(m=t.fn(null,r,b,1-(E===g?l:0)),r[E][n]=E<g?t.fnP(r[E+1][n],m):m):r[E][n]=E<g?r[E+1][n]:t.fn(null,r,F,_):(m=b>g?h:t.fn(null,r,b,1),r[E][n]=b<g?t.fnP(r[E+1][n],m):m),S++;F=d}t.avg&&avgFn(r,n),t.sum&&sumFn(r,n,h)},_bsgt=e=>(t,r)=>t>(null==e(r)?-1/0:e(r)),_bslt=e=>(t,r)=>t<(null==e(r)?-1/0:e(r)),bsLeft=(e,t,r,n,s)=>{let o;for(;r<n;)s(e,t[o=Math.floor(r+(n-r)/2)])?r=o+1:n=o;return r},bsRight=(e,t,r,n,s)=>{let o;for(;r<n;)s(e,t[o=Math.floor(r+(n-r)/2)])?n=o:r=o+1;return n},executeRange=(e,t,r,n,s,o,l,i,c)=>{const a=len(e),u=t.min,p=t.max,f=t.count?0:null,h=e=>e[c],_=t.desc,g=_?_bsgt(h):_bslt(h),d=_?_bslt(h):_bsgt(h),m=l,S=i;let E,b,x,N,A,k,R,O,w,F,T,C,I,L,y,W,j,$,U=-1,P=0,v=-1;for(_&&(l=-l,i=-i),t.fromWin=!0;++v<a;){for(k=!1,T=P,F=b=(x=P+(E=e[v]))-1,O=!0,N=0;N<E;)if(A=P+N,s&&m===-1/0)if(0===S){for(F=A,T=A,I=t.fn(null,r,A,1),w=A===P?I:t.fnP(r[A-1][n],I),C=r[A++][c];A<x&&C===r[A][c];)w=t.fnP(w,t.fn(null,r,A,1)),T=A++;for(;F<=T;)r[F++][n]=w;N=A-P}else C=r[A][c],F=T,(T=bsRight(null!=C?C+i:-1/0,r,P,x,g))===P?r[A][n]=f:F<T?(w=t.fn(null,r,F,T-F),r[A][n]=A===P?w:t.fnP(r[A-1][n],w)):r[A][n]=r[A-1][n],N++;else{if(o&&S===1/0){k=!0;break}C=r[A][c],L=F,y=T,F=bsLeft(null!=C?C+l:-1/0,r,P,x,d),(T=bsRight(null!=C?C+i:-1/0,r,P,x,g))===P||F===x||F===T?r[A][n]=f:O||L===y?(O=!1,u||p?(R=new Tree,t.fn(null,r,F,T-F,R),r[A][n]=u?R.minValue:R.maxValue):r[A][n]=t.fn(null,r,F,T-F)):(j=minFn(y,F),$=maxFn(y,F),u||p?(F>L&&t.fn(null,r,L,j-L,R,!0),T>y&&t.fn(null,r,$,T-$,R),r[A][n]=u?R.minValue:R.maxValue):(W=F>L?t.fnM(r[A-1][n],t.fn(null,r,L,j-L)):r[A-1][n],r[A][n]=T>y?t.fnP(W,t.fn(null,r,$,T-$)):W)),N++}if(k)for(U=P-1,N=0;N<E;)if(A=b-N,0===m){for(F=A,T=A,I=t.fn(null,r,A,1),w=A===b?I:t.fnP(r[A+1][n],I),C=r[A--][c];A>U&&C===r[A][c];)w=t.fnP(w,t.fn(null,r,A,1)),F=A--;for(;F<=T;)r[F++][n]=w;N+=T-A}else C=r[A][c],T=F,(F=bsLeft(null!=C?C+l:-1/0,r,P,x,d)-1)===b?r[A][n]=f:F<T?(w=t.fn(null,r,F+1,T-F),r[A][n]=A===b?w:t.fnP(r[A+1][n],w)):r[A][n]=r[A+1][n],N++;P=x}t.avg&&avgFn(r,n),t.sum&&sumFn(r,n,null)},toGroups=(e,t,r,n,s,o,l)=>{const i=len(e);let c,a,u,p,f,h,_=0,g=-1;for(;++g<i;){for(c=e[g],h=len(r),a=0;a<c;){for(f=n[u=_+a][l],p=u,u=_+ ++a;a<c&&n[u][l]===f;)u=_+ ++a;s(p,u-p),n[p][o]=u-p,r.push(n[p])}t.push(len(r)-h),_+=c}},fromGroups=(e,t,r,n,s)=>{const o=len(e);let l,i,c,a,u,p=0,f=-1;for(;++f<o;){for(l=e[f],i=0;i<l;)for(a=r(c=p+i),u=-1;++u<t[c][n];)t[p+i++][s]=a;p+=l}},avg_fn=e=>(t,r,n,s)=>{const o=n+s;let l,i=0,c=0;for(;n<o;)i+=(l=e(r[n++])).sum,c+=l.count;return{sum:i,count:c}},executeGroups=(e,t,r,n,s,o,l,i,c)=>{const a=Symbol(),u=Symbol(),p=t.avg;let f,h=[],_=[];return p&&(t.fromWin=!0),f=((e,n)=>r[e][a]=t.fn(null,r,e,n)),toGroups(e,_,h,r,f,u,c),t.count?(t=_SUM(a)).count=!0:t=t.groupsFn(a),p&&(t.fn=avg_fn(aFn(a))),executeRows(_,t,h,n,s,o,l,i),fromGroups(e,r,f=(e=>r[e][n]),u,n)},executeRowNumber=(e,t,r)=>{const n=len(e);let s,o,l=0,i=-1;for(;++i<n;){for(s=e[i],o=-1;++o<s;)t[l+o][r]=o+1;l+=s}},executeRank=(e,t,r,n,s)=>{const o=len(e);let l,i,c,a,u,p,f=0,h=-1;for(;++h<o;){for(l=e[h],i=0,p=1;i<l;)for(a=t[c=f+i][n],u=s?p++:i+1,t[c][r]=u,c=f+ ++i;i<l&&t[c][n]===a;)t[c][r]=u,c=f+ ++i;f+=l}},executePercentRank=(e,t,r,n)=>{const s=len(e);let o,l,i,c,a,u=0,p=-1;for(;++p<s;){for(o=e[p],l=0;l<o;)for(c=t[i=u+l][n],a=l?l/(o-1):0,t[i][r]=a,i=u+ ++l;l<o&&t[i][n]===c;)t[i][r]=a,i=u+ ++l;u+=o}},executeCumeDist=(e,t,r,n)=>{const s=len(e);let o,l,i,c,a,u,p,f,h=0,_=-1;for(;++_<s;){for(o=e[_],l=0;l<o;){for(c=t[i=h+l][n],u=l,i=h+ ++l;l<o&&t[i][n]===c;)i=h+ ++l;for(a=l/o,f=l-u,l=u,p=-1;l<o&&++p<f;)t[h+l++][r]=a}h+=o}},executeNTile=(e,t,r,n,s)=>{const o=len(e);let l,i,c,a,u,p,f,h=0,_=-1;for(;++_<o;){for(l=e[_],i=0,a=floor(l/s),u=l%s,p=0;p<s;){for(f=-1;++f<a;)t[c=h+i][r]=p+1,i++;u&&(u--,t[c=h+i][r]=p+1,i++),p++}h+=l}},executeLead=(e,t,r,n,s,o)=>{const l=len(e);let i,c,a,u,p=0,f=-1;for(;++f<l;){for(i=e[f],c=-1;++c<i;)u=c+n,t[a=p+c][o]=u>=i||u<0?s:t[a+n][r];p+=i}},executeFirstValue=(e,t,r,n,s)=>{const o=len(e);let l,i,c,a,u,p=0,f=-1;for(;++f<o;){for(l=e[f],a=(u=n<0?l-1:n)>=l?null:t[p+u][r],i=-1;++i<l;)t[c=p+i][s]=a;p+=l}},checkIntFB=e=>Number.isInteger(e)&&e>=0,checkFloatFB=e=>isNumber(e)&&e>=0,err1="invalid frame boundaries",more="more frame boundaries expected",less="less frame boundaries expected",gte="(>= 0)",checkUnBounded=(e,t,r,n)=>{let s=t?1:0,o=e[s++];if(isNumber(o)){(r?checkFloatFB:checkIntFB)(o)||_throw(`${r?"number":"integer"} (>= 0) expected (SELECT ${n})`),(o=e[s])&&(o.prec||o.fol)||_throw(`${err1} (SELECT ${n})`)}else o&&(o.cr||t&&o.uf)||_throw(`${err1} (SELECT ${n})`)},unBoundedFn=(e,t,r,n,s,o,l)=>{let i=!!e[0].up,c=i?1:0,a=e[c++];if(a.cr&&(a=0),isNumber(a)){let u=a;a=e[c],u>0&&a.prec&&(u=-u),o(t,r,n,s,i,!i,i?-1/0:u,i?u:1/0,l)}else executeUnordered(t,r,n,s)},checkB=(e,t,r,n)=>{let s=e[t++];if(isNumber(s)){(r?checkFloatFB:checkIntFB)(s)||_throw(`${r?"number":"integer"} (>= 0) expected (SELECT ${n})`),(s=e[t++])&&(s.prec||s.fol)||_throw(`${err1} (SELECT ${n})`)}else s&&s.cr?s=PRECEDING:_throw(`${err1} (SELECT ${n})`);return{next:s,ind:t}},checkBounded=(e,t,r)=>{let{next:n,ind:s}=checkB(e,0,t,r),{next:o,ind:l}=checkB(e,s,t,r);len(e)!==l&&_throw(`${err1} (SELECT ${r})`),n.fol&&o.prec&&_throw(`${err1} (SELECT ${r})`)},bFn=(e,t)=>{let r=e[t++],n=0;return isNumber(r)&&(n=r,r=e[t++],n>0&&r.prec&&(n=-n)),{num:n,ind:t}},boundedFn=(e,t,r,n,s,o,l)=>{let{num:i,ind:c}=bFn(e,0),{num:a}=bFn(e,c);i>a?exNulls(r,n,s):o(t,r,n,s,!0,!0,i,a,l)},isUnbounded=e=>null!=e[0]&&e[0].up||null!=last(e)&&last(e).uf,checkFrame=(e,t,r)=>{const n=e.frame_boundaries,s=len(n);s<2&&_throw(`${more} (SELECT ${r})`),s>4&&_throw(`${less} (SELECT ${r})`),isUnbounded(n)?checkUnBounded(n,n[0].up,t,r):checkBounded(n,t,r)},frameFn=(e,t,r,n,s,o)=>{const l=e.frame_boundaries;(isUnbounded(l)?unBoundedFn:boundedFn)(l,t,r,n,s,e.fn,o)},frameAbbr=(e,t,r)=>isNumber(t)?r&&r.prec?e(t,r,CURRENT_ROW):e(CURRENT_ROW,t,r):t&&t.up?e(t,CURRENT_ROW):e(CURRENT_ROW,t),checkSub=(e,t,r,n,s)=>{if(!isSubset(e,t)){const o=difference(e,t),l=intersect(o,r),i=len(l)?l[0]:o[0];isObject(n)?n=`SELECT ${n.ind}`:isArray(n)&&(n=`SELECT ${map(fnToAlias)(n).indexOf(i)+1}`),len(l)&&_throw(`column ${i} (${n}) ambiguous${s||""}`),_throw(`column ${i} (${n}) does not exist${s||""}`)}},stringCheck=(e,t)=>{isString(e)&&e||_throw(`string expected (${t})`)},strColsCheck=(e,t)=>{nul(e)&&_throw(`string expected (${t})`);for(let r of e)stringCheck(r,t)},checkStr=(e,t)=>{"*"===e&&_throw(`asterisk (${t})`),isElem(".",e)&&_throw(`${e}: point character (${t})`),parseInt(e)+""===e&&_throw(`${e}: all digits (${t})`),col(e)&&!{}[e]||_throw(`${e}: invalid name (${t})`)},strNulCheck=(e,t)=>{nul(e)&&(isArray(t)&&(t=`SELECT ${t.indexOf(e)+1}`),_throw(`empty string (${t})`))},checkColumnStr=(e,t)=>{strNulCheck(e,t),trim(e)!==e&&_throw(`${trim(e)}: leading/trailing space (${t})`),checkStr(e,t)},pgFn=e=>!(0===e||2===e||4===e),checkOrder=(e,t,r)=>{const n=[],s=e.columns,o=len(s);let l,i,c=0,a=!1;for(;c<o;)l=s[c],a?isObject(l)?(t(i=l.ord_ind)&&_throw(`invalid option in ${r}`),a=!1):n.push(l):isString(l)?(n.push(l),a=!0):_throw(`invalid parameters (${r})`),c++;return n},order_fns=[e=>ascn(t=>t[e]),e=>descn(t=>t[e]),e=>ascn(t=>toLower(t[e])),e=>descn(t=>toLower(t[e])),e=>ascn_loc(t=>t[e]),e=>descn_loc(t=>t[e])],orderbyFn=(e,t)=>{if(t&&nul(t))return[];const r=e.columns,n=[],s=len(r);let o,l,i,c=0;for(;c<s;)o=r[c],i=!0,c+1<s&&(l=r[c+1],isObject(l)?(n.push(order_fns[l.ord_ind](o)),i=!1,c++):n.push(order_fns[0](o))),c++;return c===s&&i&&n.push(order_fns[0](o)),t?t.sort(cmp(n)):n},partitionFn=(e,t,r)=>{let n=orderbyFn(e);const s=_eqs(map(e=>(t,r)=>0===e(t,r))(n));t&&(n=append(n,orderbyFn(t)));const o=cmp(n);return r.sort(o),_section(s,r)},checkOver=(e,t,r,n)=>{const s=e.WIN,o=s.clauses,l=e.framed;let i,c,a,u,p,f,h=-1;for(let e of o)(i=e.over_ind)<h&&_throw(`OVER clauses: wrong order (SELECT ${n})`),i===h&&_throw(`OVER clauses: duplicates (SELECT ${n})`),0===i?c=e:1===i?a=e:2===i?u=e:_throw(`OVER clauses: invalid clause (SELECT ${n})`),h=i;if(c){const e=`PARTITION_BY ${n}`;p=checkOrder(c,pgFn,e),strColsCheck(p,e),checkSub(p,t,r,e)}a&&(f=checkOrderBy(a,t,r,n,e.med)),l?(a?(u||(u=RANGE_BETWEEN(UNBOUNDED_PRECEDING,CURRENT_ROW)),u.range&&1!==len(f)&&_throw(`1 column expected (ORDER_BY ${n})`)):(u||(u=ROWS_BETWEEN(UNBOUNDED_PRECEDING,UNBOUNDED_FOLLOWING)),u.range&&_throw(`ORDER_BY expected (SELECT ${n})`)),checkFrame(u,u.range,e.ind)):a?e.row_num||1===len(f)||_throw(`1 column expected (ORDER_BY ${e.wg?"WITHIN_GROUP ":""}${n})`):e.row_num||_throw(`ORDER_BY expected (${e.wg?"WITHIN_GROUP ":"SELECT "}${n})`),s.props={partitionby:c,orderby:a,frame:u,partColumns:p,ordColumns:f,framed:l}},overFn=(e,t,r,n)=>{const{partitionby:s,orderby:o,frame:l,ordColumns:i,framed:c}=e.props,a=s?partitionFn(s,o,t):o?(orderbyFn(o,t),[len(t)]):[len(t)];if(o)if(c){if(l.range){const e=last(o.columns);!isObject(e)||1!==e.ord_ind&&3!==e.ord_ind&&5!==e.ord_ind||(r.desc=!0)}frameFn(l,a,r,t,n,last(i))}else r.fn(a,t,last(i));else c?executeUnordered(a,r,t,n):r.fn(a,t)},checkProp=e=>(isString(e)?e=trim(e):isObject(e)&&(e.nested=!0),e),aggrWin=(e,t,r,n,s)=>({aggregate:!0,win:!0,WIN:e,AS:t,isFn:!0,winonly:!0,err:r,expr:n,prop:s}),_RN=(e,t,r,n,s)=>s?{fn(t){overFn(e,t,_RN(null,this.AS.alias_str,r,n))},AS:t}:{fn(e,t,s){r(e,t,this.AS,s,n)},dense_n:n,AS:t},gte_zero=e=>Number.isInteger(e)&&e>=0,gt_zero=e=>Number.isInteger(e)&&e>0,_AS=e=>last(e)&&last(e).alias?last(e):null,_err=(e,t,r)=>t<e?"more args expected":t>e?"too many args":r,_WIN=e=>{const t=e.findIndex(e=>e&&e.OVER),r=t>-1;return{win:r,WIN:r?e[t]:null}},RN=(e,t,r)=>{let n=1;const s=_AS(e);s&&n++;const{WIN:o}=_WIN(e);let l;t===executeNTile&&(r=e[0],gt_zero(r)||(l="integer (> 0) expected"),n++);const i=aggrWin(o,s,_err(n,len(e),l)),c=_RN(o,s,t,r,!0);return extend(i,c)},checkOffset=(e,t,r,n)=>{let s,o=1,l=null,i=r;return isObject(e)&&e.OVER?i=e:(gte_zero(e)?o=e:s="integer (>= 0) expected",n++,isObject(t)&&t.OVER?i=t:(l=t,n++)),{offset:o,def:l,WIN:i,err:s,num:n}},_LEAD_LAG=(e,t,r,n,s,o)=>o?{fn(s){overFn(n,s,_LEAD_LAG(e,t,r,null,this.AS.alias_str))},prop:e,AS:s}:{fn(n,s){executeLead(n,s,e,t,r,this.AS)},prop:e,AS:s},LEAD_LAG=(e,t)=>{const r=checkProp(e[0]),n=_AS(e),{offset:s,def:o,WIN:l,err:i,num:c}=checkOffset(e[1],e[2],e[3],n?3:2),a=aggrWin(l,n,_err(c,len(e),i),!0,r),u=_LEAD_LAG(r,t*s,o,l,n,!0);return extend(u,a)},_VALUE=(e,t,r,n,s)=>s?{fn(e){overFn(t,e,_VALUE(this.prop,null,this.AS.alias_str,n))},prop:e,AS:r}:{fn(e,t){executeFirstValue(e,t,this.prop,n,r)},prop:e,AS:r},VALUE=(e,t)=>{let r=2;const n=checkProp(e[0]),s=_AS(e);s&&r++;const{WIN:o}=_WIN(e);let l;t>0&&(t=e[1],gt_zero(t)||(l="integer (> 0) expected"),t--,r++);const i=aggrWin(o,s,_err(r,len(e),l),!0,n),c=_VALUE(n,o,s,t,!0);return extend(c,i)},percentileCont=(e,t,r,n)=>{const s=len(e);if(0===s)return null;if(!r)return e[0+floor(1+n*(s-1))-1][t];const o=1+n*(s-1),l=floor(o),i=ceil(o),c=e[0+l-1][t];return c+(e[0+i-1][t]-c)*(o-l)},filterRange=(e,t,r,n)=>{const s=[],o=e+t;let l=e;for(;l<o;)null!=n[l][r]&&s.push(n[l]),l++;return s},exPWin=(e,t,r,n,s,o)=>{const l=len(e);let i,c,a,u,p,f=0,h=-1;for(;++h<l;){for(i=e[h],p=filterRange(f,i,n,t),u=percentileCont(p,n,o,s),c=-1;++c<i;)t[a=f+c][r]=u;f+=i}},_PERCENTILE=(e,t,r,n,s,o)=>o?{fn(e){overFn(r,e,_PERCENTILE(this.prop,t,null,this.AS.alias_str,s))},prop:e,AS:n}:{fn(e,r,o,l){if(isArray(e))return void exPWin(e,r,n,this.prop,t,s);r=orderbyFn(this.orderby,filterRange(o,l,this.prop,r));const i=percentileCont(r,this.prop,s,t);return this.AS?e[this.AS.alias_str]=i:i},prop:e,AS:r},PERCENTILE=(e,t,r,n)=>{let s=2;const o=_AS(e);o&&s++;const{win:l,WIN:i}=_WIN(e);l&&s++;const c=e.findIndex(e=>e&&e.wg),a=c>-1?e[c]:null;let u=e[0];return isNumber(u)&&u>=0&&u<=1||(r="number (0 <= n <= 1) expected"),{aggregate:!0,win:l,aggr:!l,WIN:i,wg:!0,WG:a,AS:o,med:n,framed:!1,expr:!1,isFn:!0,err:_err(s,len(e),r),params:{n:u,cont:t}}},median=e=>{let t=e[0];const r=[.5,WITHIN_GROUP(ORDER_BY(isString(t)?trim(t):t))];let n=1;const{win:s,WIN:o}=_WIN(e);s&&(r.push(o),n++);const l=_AS(e);return l&&(r.push(l),n++),PERCENTILE(r,!0,_err(n,len(e),null),!0)},aggr=(e,t)=>{let r=1;const n=_AS(e);n&&r++;const{win:s,WIN:o}=_WIN(e);s&&r++;const l=_err(r,len(e),null),i=checkProp(e[0]),c={aggregate:!0,win:s,aggr:!s,WIN:o,prop:i,AS:n,framed:!0,expr:!0,isFn:!0,err:l},a=t(i,s?o:n,n,s);return Object.assign(c,a)},uniq=(e,t,r,n)=>{const s=[],o=new Set,l=r+n;let i;for(;r<l;)i=e[r++],o.has(t(i))||(o.add(t(i)),s.push(i));return s},aggrDist=(e,t)=>{let r=1;const n=_AS(e);n&&r++;const s=_err(r,len(e),null),o=checkProp(e[0]);return{aggregate:!0,win:!1,aggr:!0,prop:o,AS:n,expr:!0,isFn:!0,err:s,fn:(e,r,s,l)=>(r=uniq(r,aFn(o),s,l),t(o,n).fn(e,r,0,len(r)))}},svc=":",_take=e=>_slice(e,1,-1),col=e=>!(":"===e[0]&&":"===e[len(e)-1]),scalarFn=e=>t=>{const r=e.nested?e.props:init(e.props),n=map(e=>isString(e)&&col(e)||isSymbol(e)?t[e]:isNumber(e)?e:isString(e)?_take(e):scalarFn(e)(t))(r),s=e.fn(...n);return e.nested?s:t[last(e.props).alias_str]=s},isSymbol=e=>"symbol"==typeof e,aFn=e=>isString(e)||isSymbol(e)?t=>t[e]:scalarFn(e),_count=(e,t,r,n)=>{if(1===n)return null==t(e[r])?0:1;const s=r+n;let o=0;for(;r<s;)null!=t(e[r++])&&o++;return o},_COUNT=(e,t,r,n)=>n?{fn(e){overFn(t,e,_COUNT(this.prop),this.AS.alias_str)},prop:e,AS:r,count:!0}:{fn(e,t,r,n){const s="*"===this.prop?n:_count(t,aFn(this.prop),r,n);return this.AS?e[this.AS.alias_str]=s:s},fnP:(e,t)=>e+t,fnM:(e,t)=>e-t,count:!0,prop:e,AS:t},objP=(e,t)=>({sum:(e?e.sum:0)+(t?t.sum:0),count:(e?e.count:0)+(t?t.count:0)}),objM=(e,t)=>({sum:(e?e.sum:0)-(t?t.sum:0),count:(e?e.count:0)-(t?t.count:0)}),_sum=(e,t,r,n,s)=>{const o=r+n;let l,i=0,c=0;for(;r<o;)null!=(l=t(e[r++]))&&(i+=l,c++);return s?{sum:i,count:c}:c?i:null},_SUM=(e,t,r,n)=>n?{fn(e){overFn(t,e,_SUM(this.prop),this.AS.alias_str)},prop:e,AS:r}:{fn(e,t,r,n){const s=_sum(t,aFn(this.prop),r,n,this&&this.fromWin);return this.AS?e[this.AS.alias_str]=s:s},fnP:(e,t)=>objP(e,t),fnM:(e,t)=>objM(e,t),sum:!0,prop:e,AS:t,groupsFn:_SUM},_avg=(e,t,r,n,s)=>{const o=r+n;let l,i=0,c=0;for(;r<o;)null!=(l=t(e[r++]))&&(i+=l,c++);return s?{sum:i,count:c}:c?i/c:null},_AVG=(e,t,r,n)=>n?{fn(e){overFn(t,e,_AVG(this.prop),this.AS.alias_str)},prop:e,AS:r}:{fn(e,t,r,n){const s=_avg(t,aFn(this.prop),r,n,this&&this.fromWin);return this.AS?e[this.AS.alias_str]=s:s},fnP:(e,t)=>objP(e,t),fnM:(e,t)=>objM(e,t),avg:!0,prop:e,AS:t,groupsFn:_AVG},_min=(e,t)=>null!=e&&null!=t?t<e?t:e:null==e?t:e,_max=(e,t)=>null!=e&&null!=t?t>e?t:e:null==e?t:e,minmax=(e,t,r,n,s)=>{if(1===n)return t(e[r]);const o=r+n;let l=t(e[r++]);for(;r<o;)l=s(t(e[r++]),l);return l},treeIns=(e,t,r,n,s)=>{const o=r+n;let l;for(;r<o;)null!=(l=t(e[r]))&&s.insert(l),r++},treeRem=(e,t,r,n,s)=>{const o=r+n;let l;for(;r<o;)null!=(l=t(e[r]))&&s.remove(l),r++},_MIN=(e,t,r,n)=>n?{fn(e){overFn(t,e,_MIN(this.prop),this.AS.alias_str)},prop:e,AS:r}:{fn(e,t,r,n,s,o){const l=(s?o?treeRem:treeIns:minmax)(t,aFn(this.prop),r,n,s||_min);return this.AS?e[this.AS.alias_str]=l:l},fnP:_min,min:!0,prop:e,AS:t,groupsFn:_MIN},_MAX=(e,t,r,n)=>n?{fn(e){overFn(t,e,_MAX(this.prop),this.AS.alias_str)},prop:e,AS:r}:{fn(e,t,r,n,s,o){const l=(s?o?treeRem:treeIns:minmax)(t,aFn(this.prop),r,n,s||_max);return this.AS?e[this.AS.alias_str]=l:l},fnP:_max,max:!0,prop:e,AS:t,groupsFn:_MAX},_section=(e,t)=>{const r=len(t),n=[];let s,o=0,l=0;for(;l<r;){for(s=l+1;s<r&&e(t[l],t[s]);)s++;n[o++]=s-l,l=s}return n},_math=(e,t)=>{const r=len(e);if(!r)return 0;let n,s=0,o=e[s++];if(null==o)return null;for(;s<r;){if(null==(n=e[s++]))return null;o=t(o,n)}return o},add=(...e)=>_math(e,(e,t)=>e+t),sub=(...e)=>_math(e,(e,t)=>e-t),mul=(...e)=>_math(e,(e,t)=>e*t),div=(...e)=>_math(e,(e,t)=>e/t),scalar=(e,t)=>({scalar:!0,fn:e,props:t=map(checkProp)(t),isFn:!0}),_len=e=>null==e[0]?null:e[0].length,_round=e=>null==e[0]?null:Math.round(e[0]),checkAliasString=(e,t)=>(isString(e)&&(e=trim(e)),stringCheck(e,`SELECT ${t} AS`),checkStr(e,`SELECT ${t} AS`),e),checkScalarAliases=e=>{const t=e.props;if(!nul(t)&&last(t).alias){let r=last(t).alias_str;return r=checkAliasString(r,e.ind),last(t).alias_str=r,r}_throw(`AS expected (SELECT ${e.ind})`)},checkAggregateAliases=e=>{if(e.AS&&e.AS.alias){let t=e.AS.alias_str;return t=checkAliasString(t,e.ind),e.AS.alias_str=t,t}_throw(`AS expected (SELECT ${e.ind})`)},_isAggr=e=>any(e=>isObject(e)&&(e.aggr||e.scalar&&_isAggr(e.props)))(e),isAggr=(e,t)=>any(e=>isString(e)&&isElem(e,t)||isObject(e)&&(e.aggr||e.scalar&&isAggr(e.props,t)))(e),isWin=(e,t)=>any(e=>isString(e)&&isElem(e,t)||isObject(e)&&(e.win||e.scalar&&isWin(e.props,t)))(e),checkScalar=(e,t,r,n)=>{const s=init(e.props);return isWin(s,r)?(e.win=!0,r.push(n),void(_isAggr(s)&&(e.winaggr=!0))):isAggr(s,t)?(e.aggr=!0,void t.push(n)):void(e.scal=!0)},checkAliases=e=>{const t=[],r=[];let n;for(let s of e)if(s.scalar)n=checkScalarAliases(s),checkScalar(s,t,r,n);else if(n=checkAggregateAliases(s),s.win){r.push(n);const e=s.prop;isObject(e)&&(e.aggr||e.scalar&&_isAggr(e.props))&&(s.winaggr=!0)}else t.push(n);return{aa:t,wa:r}},_checkProp=(e,t)=>{(isString(e)?!nul(e):isObject(e)&&e.isFn)||_throw(`invalid parameter (SELECT ${t})`)},checkParams=(e,t)=>{nul(e)&&_throw(`parameters expected (SELECT ${t})`);for(let r of e)(isString(r)?!nul(r):isObject(r)?r.isFn:isNumber(r))||(isObject(r)&&r.alias&&_throw(`nested AS (SELECT ${t})`),_throw(`invalid parameter (SELECT ${t})`))},checkWG=e=>{e.WG&&1===e.WG.wg_ind||_throw(`WITHIN_GROUP expected (SELECT ${e.ind})`),e.WG.orderby&&0===e.WG.orderby.wg_ind||_throw(`ORDER_BY expected (WITHIN_GROUP SELECT ${e.ind})`),e.aggr&&(e.orderby=e.WG.orderby),e.WIN=OVER(...e.win?e.WIN.clauses:[],e.WG.orderby)},appendObj=e=>{e.prop=e.WIN.props.ordColumns[0];const t=_PERCENTILE(e.prop,e.params.n,e.win?e.WIN:e.AS,e.AS,e.params.cont,e.win);Object.assign(e,t)},checkAggregateFn=(e,t,r,n)=>{e.nested&&e.AS&&_throw(`nested AS (SELECT ${n})`),!e.winonly||e.WIN&&e.WIN.OVER||_throw(`OVER expected (SELECT ${n})`),e.wg&&checkWG(e),e.err&&_throw(`${e.err} (SELECT ${n})`),e.expr&&_checkProp(e.prop,n),(e.win||e.wg)&&checkOver(e,t,r,n),e.wg&&appendObj(e)},isNested=(e,t,r)=>isElem(t,r.wa)||e&&isElem(t,r.aa),scalInd=0,startInd=1,restInd=2,overInd=3,checkNesting=(e,t,r,n,s,o)=>{const l=[[],[],[],[]];if(e.aggregate){(0===t||e.win&&2===t)&&_throw(`nesting error (SELECT ${s})`),t=e.aggr?0:2,checkAggregateFn(e,r,n,s);const i=e.prop;if(e.win){const t=e.WIN.props.partColumns,r=e.WIN.props.ordColumns;t&&l[3].push(...t),r&&l[3].push(...r)}if(!isString(i)||e.count&&"*"===i){if(isObject(i)){const e=checkNesting(i,t,r,n,s,o);each((e,t)=>l[t].push(...e))(e)}}else isNested(e.aggr,i,o)&&_throw(`nesting error (SELECT ${s+" "+i})`),l[t].push(i)}else{const i=e.nested?e.props:init(e.props);checkParams(i,s);for(let e of i)if(isString(e)&&col(e))o&&1!==t&&isNested(0===t,e,o)&&_throw(`nesting error (SELECT ${s+" "+e})`),l[t].push(e);else if(isObject(e)){const i=checkNesting(e,t,r,n,s,o);each((e,t)=>l[t].push(...e))(i)}}return l},aliasFn=e=>(e.aggregate?e.AS:last(e.props)).alias_str,checkScal=(e,t,r)=>{const n=[],s=[];let o,l;for(let i of e)l=checkNesting(i,0,null,r,i.ind,null),checkSub(l[0],t,r,i),o=aliasFn(i),t.push(o),s.push(o),n.push(...l[0]);return{scal_names:n,sa:s}},checkAggr=(e,t,r,n,s)=>{const o=[],l=[];let i;for(let c of e)i=checkNesting(c,1,t,r,c.ind,s),checkSub(i[0],t,r,c),checkSub(i[1],append(l,n),[],c),l.push(aliasFn(c)),o.push(...i[0],...i[1]);return{aggr_names:o,aa:l,input:append(n,l)}},checkWin=(e,t,r,n,s,o)=>{const l=[],i=[];let c;for(let a of e)c=checkNesting(a,1,t,n,a.ind,o),checkSub(c[0],r,n,a),checkSub(c[1],append(t,i),s?[]:n,a),checkSub(c[2],t,s?[]:n,a),i.push(aliasFn(a)),l.push(...c[0],...c[1],...c[2],...c[3]);return t.push(...i),{win_names:l,wa:i}},checkOrderBy=(e,t,r,n,s)=>{const o=`${s?"SELECT":"ORDER_BY"}${n?" "+n:""}`,l=checkOrder(e,e=>e<0||e>5,o);return strColsCheck(l,o),checkSub(l,t,r,o),l},executeScalars=(e,t)=>{const r=map(scalarFn)(t);for(let t of e)for(let e of r)e(t)},whereFn=(e,t)=>filter(e.pred)(t),groupbyFn=(e,t)=>nul(t)?[]:partitionFn(e,null,t),scalarAggrFn=(e,t,r,n,s)=>{const o=e.nested?e.props:init(e.props),l=map(e=>isString(e)&&col(e)?t[e]:isNumber(e)?e:isString(e)?_take(e):e.aggregate?e.fn(t,r,n,s):scalarAggrFn(e,t,r,n,s))(o),i=e.fn(...l);return e.nested?i:t[last(e.props).alias_str]=i},_scalarAggrFn=e=>(t,r,n,s)=>scalarAggrFn(e,t,r,n,s),waFn=e=>{const t=e.prop,r=Symbol(),n={alias_str:r};return e.prop=r,t.aggr?(t.AS=n,t.fn.bind(t)):(t.props.push(n),t.nested=!1,_scalarAggrFn(t))},scalWaFn=e=>{const t=map((e,t,r)=>{if(isObject(e)&&e.isFn){if(e.win&&!isString(e.prop))return waFn(e);if(e.aggr){const n=e,s=Symbol(),o={alias_str:s};return r[t]=s,n.AS=o,n.fn.bind(n)}return e.scalar?scalWaFn(e):e}return e})(e.props);return(e,r,n,s)=>{each(t=>isFunction(t)?t(e,r,n,s):t)(t)}},executeAggregates=(e,t,r)=>{const n=len(e),s=Array(n);let o=-1;for(;++o<n;)s[o]={};const l=r=>{const o=isString(r)?(e,t,n)=>e[r]=t[n][r]:r.aggregate?r.aggr?r.fn.bind(r):waFn(r):r.aggr?_scalarAggrFn(r):scalWaFn(r);let l,i=0,c=-1;for(;++c<n;)l=e[c],o(s[c],t,i,l),i+=l};for(let e of r)l(e);return s},scalarWinFn=(e,t)=>{e.props=map(e=>{if(e.aggregate&&e.win){const r=Symbol();e.AS={alias_str:r},e.fn(t),e=r}else e.scalar&&scalarWinFn(e,t);return e})(e.props)},executeWins=(e,t)=>{const r=[];for(let n of t)n.aggregate?n.fn(e):(scalarWinFn(n,e),r.push(n));nul(r)||executeScalars(e,r)},fnToAlias=e=>isString(e)?e:aliasFn(e),getDistinct=(e,t)=>{const r=cmp(map(e=>ascn(t=>t[e]))(e)),n=_eqs(map(e=>equalBy(t=>t[e]))(e));return t.sort(r),nubSBy(n,t)},checkStr1=(e,t,r)=>{t&&e[t]&&!isString(e[t])&&_throw(`Column ${t} (FROM ${r}) ambiguous!`)},mergeObjs=(e,t,r,n,s,o,l,i)=>{const c=e[r],a=e[n],u={};if(o)c[e[l]]=l,a[l]||(a[l]=e[l]),c[t[l]]=l,delete t[l];else for(let e of keys(a))a[e]=1;let p;checkStr1(a,l,i);for(let r of keys(e))p=e[r],t[r]&&!c[p]?(u[p]=r,a[r]=p):u[r]=p;for(let e of keys(t))p=t[e],a[e]?u[p]=e:u[e]=p;return u[r]=c,u[n]=a,u[s]=e[s],u},checkCrossJoin=(e,t,r,n,s)=>e[s]||t[s]?(e[s]=!0,e):mergeObjs(e,t,r,n,s),checkJoin=(e,t,r,n,s,o,l,i,c,a,u)=>{if(e[u]||t[u]){if(s.anti)if(s.left){if(t[u])return e}else if(e[u])return t[c]={},t[a]={},t;return e[u]=!0,e}const p=i?"USING ":"ON ";return stringCheck(r,`FROM ${p+o}`),stringCheck(n,`FROM ${p+l}`),e[r]||e[c][r]||checkSub([r],keys(e),keys(e[a]),`FROM ${p+o}`),t[n]||checkSub([n],keys(t),[],`FROM ${p+l}`),s.semi?(checkStr1(e[a],r,o),s.left?e:(t[c]={},t[a]={},t)):mergeObjs(e,t,c,a,u,i,r,o)},checkTNUniqness=e=>{if(!isUniq(e)){const t=new Set;let r,n=0;for(let s of e){if(t.has(s)){r=s;break}t.add(s),n++}_throw(`table name ${r} (FROM ${"table "+n+1}) already exists`)}},checkNext=(e,t,r,n,s)=>{const o=n+1;let l,i="t"+(len(r)+1);if(o<s&&(l=e[o],isString(l)&&(i=trim(l),strNulCheck(i,"FROM table-name"),n++)),r.push(i),checkTNUniqness(r),!nul(t))for(let e of keys(t[0]))checkColumnStr(e,i+" column");return n},copyObj=e=>Object.assign({},e),_throwErr=(e,t,r)=>{const n=`after ${t} `;e&&(isArray(r)&&_throw("FROM: "+n+"ON/USING expected"),_throw("FROM: after JOIN "+n+"table expected")),_throw("FROM: "+(isArray(r)?"":"after ON/USING ")+n+"table or JOIN expected")},checkJoinTables=e=>{const t=len(e),r=[],n=[],s=[],o=Symbol(),l=Symbol(),i=Symbol(),c=(e,t)=>mapKeys(t=>e+t,keys(t[0]||{}));let a,u,p,f,h,_=0,g=0,d="",m=e[_];for(isArray(m)||_throw("FROM: table expected as first parameter"),_=checkNext(e,m,r,_,t),u=c((h=r[g++])+".",m),n.push(copyObj(u)),u[o]={},u[l]={},u[i]=nul(m),s.push([null,extend(u,u[o])]),f=m,_++;_<t;)m=e[_],isArray(m)?(a&&isArray(f)&&_throwErr(a,h,f),_=checkNext(e,m,r,_,t),d+=(d?" + ":"")+h,p=c((h=r[g++])+".",m),n.push(copyObj(p)),p[i]=nul(m),a&&!a.cross||(u=checkCrossJoin(u,p,o,l,i),s.push([null,extend(u,u[o])]),a=null)):isObject(m)&&(m.join||m.ON)?m.join?(a&&_throwErr(a,h,f),a=m):(a&&isArray(f)||_throwErr(a,h,f),u=checkJoin(u,p,m.str1,m.str2,a,d,h,m.using,o,l,i),s.push([m.str1,extend(u,u[o])]),a=null):_throwErr(a,h,f),f=m,_++;a&&_throwErr(a,h,f);const S=keys(extend(u,u[o]));return{empty:u[i],tres:keys(u),tkeys:S,ambs:keys(u[l]),inputs:n,temps:s}},zip=(e,t)=>e.map((e,r)=>[e,t[r]]),pick2Fns=(e,t,r)=>e.simple&&t.simple?pick2(e.targets,t.targets,r):e.simple?pick2KTS(e.targets,zip(t.targets,t.sources),r):t.simple?pick2TSK(zip(e.targets,e.sources),t.targets,r):pick2TS(zip(e.targets,e.sources),zip(t.targets,t.sources),r),invert=e=>{const t={};for(let r of keys(e))t[e[r]]=r;return t},joinFn=(e,t,r,n,s)=>{if(s>len(n)-1)return{table:t};const o=n[s][1],l=invert(e),i=invert(o),c=map(e=>e[0])(drop(s,n)),a=_uniq(append(r,c)),u=filter(t=>e[t]&&e[t]===o[t]||t===e[o[t]]||l[t]&&i[t])(a),p=map(e=>o[e]?e:i[e])(u),f=map(t=>e[t]&&o[t]?t:o[t])(p),h=all((e,t)=>e===f[t])(p);return{targets:p,sources:f,simple:h,table:t}},executeJoin=(e,t,r,n,s,o,l,i,c)=>{const a=i[c][1];let u;if(s.semi){const r=s.left?e:t;u=r.simple?_pick(r.targets):pickTS(zip(r.targets,r.sources))}else u=pick2Fns(e,t,o&&s.fnplus?s.fnplus(r):null);const p=s.fn({fn:u,t1:e.table,t2:t.table,str1:r,str2:n,tgs1:e.targets,tgs2:t.targets});return joinFn(a,p,l,i,c+1)},checkNextInd=(e,t,r)=>t+1<r&&isString(e[t+1])?t+1:t,_uniq=e=>[...new Set(e)],joinTables=(e,t,r,n)=>{const s=len(e);let o,l,i,c=0,a=0,u=1,p=e[0];if(1===len(n))return _select(intersect(keys(r[a]),t))(p);for(c=checkNextInd(e,c,s),l=joinFn(r[a++],p,t,n,u),c++;c<s;)p=e[c],isArray(p)?(c=checkNextInd(e,c,s),i=joinFn(r[a++],p,t,n,u),o&&!o.cross||(l=executeJoin(l,i,null,null,{fn:_prodSQL},!1,t,n,u),o=null,u++)):p.join?o=p:(l=executeJoin(l,i,p.str1,p.str2,o,p.using,t,n,u),o=null,u++),c++;return l.table},checkGroupBy=(e,t,r,n,s,o)=>{const l=checkOrder(e,pgFn,"GROUP_BY");return strColsCheck(l,"GROUP_BY"),checkSub(l,n,s,"GROUP_BY"),checkSub(append(t,r),l,[],o," in GROUP_BY"),l},checkWhere=(e,t,r,n)=>{isFunction(e.pred)||_throw(`predicate expected (${n})`);const s=e.pred+"",o=s.match(/[=(]/)[0],l=s.match("="===o?/\b\w+\b/:/(?<=\(\s*)\b\w+\b/);l||_throw(`parameter expected in predicate of ${n}`);const i="(?<=\\b"+l[0]+"\\s*",c=i+"\\.\\s*)\\w+\\b",a=i+"\\[\\s*['\"`])[^'\"`]*(?=['\"`]\\s*\\])";let u=s.match(new RegExp(c+"|"+a,"g"))||[];u=trimCols(u);for(let e of u)strNulCheck(e,n);return checkSub(u,t,r,n),u},checkUniqness=e=>{const t=map(fnToAlias)(e);if(!isUniq(t)){const r=new Set;let n,s=0;for(let e of t){if(r.has(e)){n=e;break}r.add(e),s++}_throw(`column ${n} (SELECT ${s+1}${isString(e[s])?"":" AS"}) already exists`)}},checkNotSub=(e,t)=>{const r=filter(e=>!isString(e))(t),n=map(fnToAlias)(r);if(!nul(intersect(n,e))){const t=new Set(e);let n;for(let e of r)if(t.has(fnToAlias(e))){n=e;break}_throw(`column ${fnToAlias(n)} (SELECT ${n.ind} AS) already exists [in table]`)}},checkSelects=(e,t,r,n,s)=>{if(s)for(let t of e)strNulCheck(t,n);checkUniqness(n),checkNotSub(append(t,r),n),s&&checkSub(e,t,r,n)},_selectSQL=(e,t,r,n)=>{let s=e.findIndex(e=>!(isString(e)||e.isFn));s<1&&(s>-1&&_throw("no column selected"),s=len(e));const o=take(s,e),l=drop(s,e);let i,c,a,u,p,f,h=-1;for(let e of l)(i=e.select_ind)<h&&_throw("SELECT clauses: wrong order"),i===h&&_throw("SELECT clauses: duplicates"),0===i?c=e:1===i?a=e:2===i?u=e:3===i?p=e:4===i?f=e:_throw("SELECT clauses: invalid clause"),h=i;c||_throw("FROM must be supplied");let _,g=c.tables,d=1;const m=[];for(let e of o)isString(e)||(isObject(e)&&e.isFn||_throw(`invalid argument (SELECT ${d})`),e.ind=d,_=!0,m.push(e)),d++;let S,E,b,x,N,A;_&&(S=checkAliases(m));let k=[];const R=[],O=[],w=[],F=[];for(let e of o)isString(e)?(E=!0,k.push(trim(e))):e.scal?(b=!0,R.push(e)):e.aggr?(x=!0,O.push(e)):(N=!0,w.push(e),e.winaggr&&(A=!0,F.push(e)));let T;1===s&&E&&"*"===k[0]&&(T=!0),!E&&!b||!x&&!A||u||_throw("GROUP_BY required"),p&&!u&&_throw("GROUP_BY required [before HAVING]");const{empty:C,tres:I,tkeys:L,ambs:y,inputs:W,temps:j}=checkJoinTables(g);if(C)return[];T||checkSelects(k,L,y,o,E);let $,U=copy(L),P=[],v=[],G=[],B=[],D=[],M=[],V=[],J=[],q=[],H=[];b&&({scal_names:D,sa:J}=checkScal(R,U,y));const Y=copy(U);a&&(P=checkWhere(a,U,y,"WHERE"),$=!nul(intersect(J,P))),T&&(k=I);const K=u||x;if(K){if(u){v=checkGroupBy(u,k,J,U,y,T?I:o)}({aggr_names:M,aa:q,input:U}=checkAggr(O,U,y,v,S)),p&&(G=checkWhere(p,U,[],"HAVING"))}const z=K||A;U=A&&!K?[]:U,N&&({win_names:V,wa:H}=checkWin(w,U,Y,y,z,S)),f&&(B=checkOrderBy(f,U,z?[]:y));const Q=concat(k,D,K?M:V,v,P,K?[]:B),X=append(J,K?q:H),Z=difference(Q,X);let ee=joinTables(g,Z,W,j);if($&&executeScalars(ee,R),a&&(ee=whereFn(a,ee)),!$&&b&&executeScalars(ee,R),z){const e=difference(concat(k,J,G,V,B),H),t=x||A?concat(e,O,F):e,r=u?groupbyFn(u,ee):[len(ee)];ee=executeAggregates(r,ee,t),p&&(ee=whereFn(p,ee))}N&&executeWins(ee,w);const te=_?map(fnToAlias)(o):k;return z||!t||nul(ee)||(ee=getDistinct(te,ee)),f&&orderbyFn(f,ee),r&&(ee=take(n,ee)),select(te)(ee)},trimCols=e=>map(e=>isString(e)?trim(e):e)(e),fulljoinFn=e=>(t,r,n)=>{null==r[e]&&(t[e]=null==n[e]?null:n[e])},rightjoinFn=e=>(t,r,n)=>{t[e]=null==n[e]?null:n[e]};export const JOIN={join:!0,fn:hashjoin};export const INNER_JOIN={join:!0,fn:hashjoin};export const CROSS_JOIN={join:!0,cross:!0};export const LEFT_JOIN={join:!0,fn:leftjoin};export const RIGHT_JOIN={join:!0,fn:rightjoin,fnplus:rightjoinFn};export const FULL_JOIN={join:!0,fn:fulljoin,fnplus:fulljoinFn};export const LEFT_SEMI_JOIN={join:!0,semi:!0,left:!0,fn:leftsemijoin};export const RIGHT_SEMI_JOIN={join:!0,semi:!0,fn:rightsemijoin};export const LEFT_ANTI_JOIN={join:!0,semi:!0,left:!0,anti:!0,fn:leftantijoin};export const RIGHT_ANTI_JOIN={join:!0,semi:!0,anti:!0,fn:rightantijoin};export const ON=(e,t)=>(isString(e)&&(e=trim(e)),isString(t)&&(t=trim(t)),{ON:!0,str1:e,str2:t});export const USING=e=>(isString(e)&&(e=trim(e)),{ON:!0,str1:e,str2:e,using:!0});export const UNBOUNDED_PRECEDING={up:!0};export const PRECEDING={prec:!0};export const CURRENT_ROW={cr:!0};export const FOLLOWING={fol:!0};export const UNBOUNDED_FOLLOWING={uf:!0};export const ROWS_BETWEEN=(...e)=>({frame_boundaries:e,over_ind:2,rows:!0,fn:executeRows});export const RANGE_BETWEEN=(...e)=>({frame_boundaries:e,over_ind:2,range:!0,fn:executeRange});export const GROUPS_BETWEEN=(...e)=>({frame_boundaries:e,over_ind:2,groups:!0,fn:executeGroups});export const ROWS=(e,t)=>frameAbbr(ROWS_BETWEEN,e,t);export const RANGE=(e,t)=>frameAbbr(RANGE_BETWEEN,e,t);export const GROUPS=(e,t)=>frameAbbr(GROUPS_BETWEEN,e,t);export const PARTITION_BY=(...e)=>({columns:e=trimCols(e),over_ind:0});export const OVER=(...e)=>({clauses:e,OVER:!0});export const ROW_NUMBER=(...e)=>{const t=RN(e,executeRowNumber);return t.row_num=!0,t};export const RANK=(...e)=>RN(e,executeRank);export const DENSE_RANK=(...e)=>RN(e,executeRank,!0);export const PERCENT_RANK=(...e)=>RN(e,executePercentRank);export const CUME_DIST=(...e)=>RN(e,executeCumeDist);export const NTILE=(...e)=>RN(e,executeNTile);export const LEAD=(...e)=>LEAD_LAG(e,1);export const LAG=(...e)=>LEAD_LAG(e,-1);export const FIRST_VALUE=(...e)=>VALUE(e,0);export const LAST_VALUE=(...e)=>VALUE(e,-1);export const NTH_VALUE=(...e)=>VALUE(e,1);export const WITHIN_GROUP=e=>({orderby:e,wg:!0,wg_ind:1});export const PERCENTILE_CONT=(...e)=>PERCENTILE(e,!0);export const MEDIAN=(...e)=>median(e);export const PERCENTILE_DISC=(...e)=>PERCENTILE(e);export const COUNT=(...e)=>aggr(e,_COUNT);export const SUM=(...e)=>aggr(e,_SUM);export const AVG=(...e)=>aggr(e,_AVG);export const MIN=(...e)=>aggr(e,_MIN);export const MAX=(...e)=>aggr(e,_MAX);export const COUNT_DISTINCT=(...e)=>aggrDist(e,_COUNT);export const SUM_DISTINCT=(...e)=>aggrDist(e,_SUM);export const AVG_DISTINCT=(...e)=>aggrDist(e,_AVG);export const AS=e=>({alias:!0,alias_str:e});export const ID=(...e)=>scalar(e=>e,e);export const LEN=(...e)=>scalar(_len,e);export const ROUND=(...e)=>scalar(_round,e);export const ADD=(...e)=>scalar(add,e);export const SUB=(...e)=>scalar(sub,e);export const DIV=(...e)=>scalar(div,e);export const MUL=(...e)=>scalar(mul,e);export const FROM=(...e)=>({tables:e,select_ind:0});export const WHERE=e=>({pred:e,select_ind:1});export const GROUP_BY=(...e)=>({columns:e=trimCols(e),select_ind:2});export const HAVING=e=>({pred:e,select_ind:3});export const ASC={ord_ind:0};export const DESC={ord_ind:1};export const NOCASE_ASC={ord_ind:2};export const NOCASE_DESC={ord_ind:3};export const ASC_LOC={ord_ind:4};export const DESC_LOC={ord_ind:5};export const ORDER_BY=(...e)=>({columns:e=trimCols(e),select_ind:4,over_ind:1,wg_ind:0});export const SELECT=(...e)=>_selectSQL(e);export const SELECT_TOP=e=>(...t)=>_selectSQL(t,!1,!0,e);export const SELECT_DISTINCT=(...e)=>_selectSQL(e,!0);export const SELECT_DISTINCT_TOP=e=>(...t)=>_selectSQL(t,!0,!0,e);export const createFn=e=>(...t)=>scalar(e,t);